<?php
// $Id: panels.module,v 1.10.4.123 2008/08/05 11:01:24 sdboyer Exp $


/**
 * @file panels.module
 * Core API for Panels. Provides display editing and rendering capabilities.
 */
function panels_help($section = NULL) {
  $output = '';
  switch ($section) {
    case 'admin/help#panels':
    case 'admin/panels':
      $output = '<p>'. t(' Panels module is the core engine for a number of sub-modules, including Panels pages, Panels nodes, Mini panels, and Views panes. Panels module allows the website adminstrator (or sometimes the end-user) to manipulate the layout of individual pages, sidebars, and content pieces, as well as easily dictate what content is displayed in the layout.') .'</p>';
      $output .= '<p>'. t('Most Drupal users are familiar with the block to region layout mechanism in which you can assign a block to any region defined in your theme.  Panels takes this concept a massive step forward.  Through the panels interface you can start by creating a layout with any number of columns, headers, and footer, and control the width of those areas.') .'</p>';
      $output .= '<p>'. t('After creating your layout, you can assign pieces of content to those areas in an easy drag and drop interface.  Content is not limited to blocks, but can be nodes, views, or other types of content that expose themselves to panels.') .'</p>';
      $output .= '<p><b>'. t('Panel pages') .'</b>'. t(' are the the primary panels module, you can use this for creating single full page layouts.  This replaces the standard panel that existed in the earlier versions of panels. If you are upgrading your site from Panels 1, and you cannot find where your panels went, be sure to enable the panel pages module!') .'</p>';
      $output .= '<p><b>'. t('Panel nodes') .'</b>'. t(' are useful for creating layouts that only occupy the content area of your pages.  Frequently, it is desirable to add an area to a node layout, such as a pull quote for a newspaper or a photo block, that you don\'t necessarily want on every node.  Panels Nodes lets you control the layout of a single node at a time and place content such as blog posts, images, blogs in and around the post.') .'</p>';
      $output .= '<p><b>'. t('Mini panels') .'</b>'. t(' are a layout mechanism for blocks.  It won\'t take long using panels before you get to a point when you want a panel inside of a panel.  Or a panel that can be used as a block.  That is exactly what mini-panels does. You can create a small panel here with various pieces of content and then put it inside of a panels-page or panels-node.') .'</p>';
      $output .= '<p><b>'. t('Views panes') .'</b>'. t(" expose views so they may be added to panels. Panels will automatically detect block views without this module; however, page and embedded views will <strong>not be</strong> selectable from Panels by default. If you enable the <strong>Views panes</strong> module, you may expose individual views to Panels. The <strong>Legacy views panes</strong> module will simply expose all views, so that you may add them in any panel. Both modules provide options for customization of the views' settings on a per-Panel basis. This is useful if you have multiple administrators or want to use panels for something other than just panel pages.") .'</p>';
      $output .= '<p>' . t('If you do not see the above items in the list below, you may need to activate them on the <a href="!url">module administration</a> page.', array('!url' => url('admin/build/modules'))) . '</p>';

      return $output;
  }
}

/**
 * Returns the API version of Panels. This didn't exist in 1.
 *
 * @return An array with the major and minor versions
 */
function panels_api_version() {
  return array(2, 0);
}

/**
 * Implementation of hook_menu
 */
function panels_menu($may_cache) {
  if ($may_cache) {
    $items[] = array(
      'path' => 'admin/panels',
      'title' => t('Panels'),
      'access' => user_access('access administration pages'),
      'callback' => 'system_admin_menu_block_page',
      'description' => t('Administer items related to the Panels module.'),
    );
    $items[] = array(
      'path' => 'panels/node/autocomplete',
      'title' => t('Autocomplete node'),
      'callback' => 'panels_node_autocomplete',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    // TODO Deprecated generalized ajax handler. Remove if at all possible.
    $items[] = array(
      'path' => 'panels/ajax',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/common/ajax',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_common_ajax'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/add-content',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax_add_content'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/add-config',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax_add_config'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/configure',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax_configure'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/toggle-shown',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax_toggle_shown'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/cache',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax_cache'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/cache-settings',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_ajax_cache_settings'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
    $items[] = array(
      'path' => 'panels/ajax/panel_settings',
      'title' => t('ajax'),
      'callback' => 'panels_ajax_passthru',
      'callback arguments' => array('panels_panel_settings_ajax'),
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK,
    );
  }
  else {
    drupal_add_css(panels_get_path('css/panels.css'));
    drupal_add_js(panels_get_path('js/panels.js'));
  }

  return $items;
}

/**
 * Load a panels include file.
 */
function panels_load_include($include, $path = 'includes/') {
  require_once './' . panels_get_path("$path$include.inc");
}

/**
 * Helper function for our AJAX stuff to call through to the right location
 */
function panels_ajax_passthru() {
  $args = func_get_args();
  $callback = array_shift($args);

  panels_load_include('plugins');
  if (arg(1) == 'common') {
    panels_load_include('common');
  }
  else {
    panels_load_include('display_edit');
  }
  return call_user_func_array($callback, $args);
}

/**
 * Simple render function to make sure output is what we want.
 * @ingroup panels_ajax
 */
// TODO it's the presence/absence of the $url var that determines whether or not the deprecated submit function gets called in the js; ensure that nothing needs in, then get rid of it.
function panels_ajax_render($output = NULL, $title = NULL, $url = NULL) {
  if (!is_object($output)) {
    $temp = new stdClass();
    $temp->output = $output;
    switch ($output) {
      case 'dismiss':
        $temp->type = $output;
        break;

      default:
        $temp->type = 'display';
    }
    $temp->title = $title;
    $temp->url   = $url;
    $output      = $temp;
  }
  if (!$output->output || !$output->type) {
    $output->output = t('The input was invalid');
    $output->type   = 'display';
    $output->title  = t('Error');
  }
  drupal_set_header('Content-Type: text/javascript; charset=utf-8');
  print drupal_to_js($output);
  exit;
}

/**
 * Handle a form for AJAX in a manner that happens to be basically the
 * opposite of the normal flow; if the form hasn't been processed,
 * just render it and exit; if it has been submitted successfuly, however,
 * then we return whatever the submit function returned and do our
 * next step accordingly.
 *
 * @param $form_id
 *   The id of the form
 * @param $title
 *   The title for the modal dialog, if rendered.
 * @param $url
 *   The next URL to go to; may be NULL.
 * @param ...
 *   Any arguments that go to the form.
 */
function panels_ajax_form($form_id, $title, $url) {
  $args = func_get_args();

  // Remove the $title and $url
  array_splice($args, 1, 2);

  $form = call_user_func_array('drupal_retrieve_form', $args);
  $form['#redirect'] = FALSE;

  $result = drupal_process_form($form_id, $form);
  if (isset($result)) {
    return $result;
  }

  // If the form wasn't submitted successfully, render the form.
  $output = theme('status_messages');
  $output .= drupal_render_form($form_id, $form);
  panels_ajax_render($output, $title, $url);
}

/**
 * panels path helper function
 */
function panels_get_path($file, $base_path = false, $module = 'panels') {
  if ($base_path) {
    $output = base_path();
  }
  return $output . drupal_get_path('module', $module) . '/' . $file;
}

/**
 * Implementation of hook_perm
 */
function panels_perm() {
  return array('view all panes', 'view pane admin links', 'administer pane visibility', 'administer pane access', 'administer advanced pane settings', 'use panels caching features');
}

// ---------------------------------------------------------------------------
// panels custom image button

/**
 * Custom form element to do our nice images.
 */
function panels_elements() {
  $type['panels_imagebutton'] = array('#input' => TRUE, '#button_type' => 'submit');
  return $type;
}

/**
 * Theme our image button.
 */
function theme_panels_imagebutton($element) {
  return '<input type="image" ' .
    'class="form-' . $element['#button_type'] . ' ' . $element['#class'] . '" ' .
    'name="'. $element['#name'] .'" ' .
    'value="'. check_plain($element['#default_value']) .'" ' .
    'id="' . $element['#id'] . '" ' .
    drupal_attributes($element['#attributes']) .
    ' src="' . base_path() . $element['#image'] . '" ' .
    'alt="' . $element['#title'] . '" ' .
    'title="' . $element['#title'] . '" ' .
    "/>\n";
}

function panels_imagebutton_value() {
  // null function guarantees default_value doesn't get moved to #value.
}

/**
 * Add a single button to a form.
 */
function panels_add_button($image, $name, $text, $class, $id = NULL) {
  return array(
    '#type' => 'panels_imagebutton',
    '#image' => panels_get_path('images/' . $image),
    '#title' => $text,
    '#default_value' => $name,
    '#class' => $class,
    '#id' => $id,
  );
}

// ---------------------------------------------------------------------------
// cache handling stuff for display editing

/**
 * Get a display from the cache; this is used if the display is currently
 * being edited, which can be a seriously multi-step process.
 */
function panels_cache_get($did) {
  return panels_common_cache_get('panels', $did);
}

/**
 * Save the edited display into the cache.
 */
function panels_cache_set($did, $cache) {
  return panels_common_cache_set('panels', $did, $cache);
}

/**
 * Clear a display from the cache; used if the editing is aborted.
 */
function panels_cache_clear($did) {
  return panels_common_cache_clear('panels', $did);
}

// ---------------------------------------------------------------------------
// cache handling stuff for non-display objects.

/**
 * Get an object from cache.
 */
function panels_common_cache_get($obj, $did, $skip_cache = FALSE) {
  static $cache = array();
  $key = "$obj:$did";
  if ($skip_cache) {
    unset($cache[$key]);
  }

  if (!array_key_exists($key, $cache)) {
    $data = db_fetch_object(db_query("SELECT * FROM {panels_object_cache} WHERE sid = '%s' AND obj = '%s' AND did = %d", session_id(), $obj, $did));
    if ($data) {
      $cache[$key] = unserialize($data->data);
    }
  }
  return isset($cache[$key]) ? $cache[$key] : NULL;
}

/**
 * Save the edited display into the cache.
 */
function panels_common_cache_set($obj, $did, $cache) {
  panels_common_cache_clear($obj, $did);
  db_query("INSERT INTO {panels_object_cache} (sid, obj, did, data, timestamp) VALUES ('%s', '%s', %d, '%s', %d)", session_id(), $obj, $did, serialize($cache), time());
}

/**
 * Clear a display from the cache; used if the editing is aborted.
 */
function panels_common_cache_clear($obj, $did) {
  db_query("DELETE FROM {panels_object_cache} WHERE sid = '%s' AND obj = '%s' AND did = %d", session_id(), $obj, $did);
}

/**
 * Clean up old caches
 */
function panels_cron() {
  // delete anything 7 days old or more.
  db_query("DELETE FROM {panels_object_cache} WHERE timestamp < %d", time() - (86400 * 7));
}

/**
 * Global storage function, used mostly so that _submit hooks can pass data
 * back to their originator more easily. TODO: deprecated but still in use.
 */
function panels_set($var, $value = NULL) {
  static $vars = array();
  if ($value !== NULL) {
    $vars[$var] = $value;
  }
  return $vars[$var];
}

/**
 * Retrieve from global storage
 */
function panels_get($var) {
  return panels_set($var);
}

// ---------------------------------------------------------------------------
// panels display editing

/**
 * Main API entry point to edit a panel display.
 *
 * @ingroup MainAPI
 *
 * Sample implementations utiltizing the the complex $destination behavior can be found
 * in panels_page_edit_content() and, in a separate contrib module, OG Blueprints
 * (http://drupal.org/project/og_blueprints), og_blueprints_blueprint_edit().
 *
 * @param object $display instanceof panels_display \n
 *  A fully loaded panels $display object, as returned from panels_load_display().
 *  Merely passing a did is NOT sufficient. \n
 *  Note that 'fully loaded' means the $display must already be loaded with any contexts
 *  the caller wishes to have set for the display.
 * @param mixed $destination \n
 *  The redirect destination that the user should be taken to on form submission or
 *  cancellation. With panels_edit, $destination has complex effects on the return
 *  values of panels_edit() once the form has been submitted. See the explanation of
 *  the return value below to understand the different types of values returned by panels_edit()
 *  at different stages of FAPI. Under most circumstances, simply passing in
 *  drupal_get_destination() is all that's necessary.
 * @param array $content_types \n
 *  An associative array of allowed content types, typically as returned from
 *  panels_common_get_allowed_types(). Note that context partially governs available content types,
 *  so you will want to create any relevant contexts using panels_create_context() or
 *  panels_create_context_empty() to make sure all the appropriate content types are available.
 *
 * @return
 *  Because the functions called by panels_edit() invoke the form API, this function
 *  returns different values depending on the stage of form submission we're at. In Drupal 5,
 *  the phase of form submission is indicated by the contents of $_POST['op']. Here's what you'll
 *  get at different stages:
 *    -# If !$_POST['op']: then we're on on the initial passthrough and the form is being
 *       rendered, so it's the $form itself that's being returned. Because negative margins,
 *       a common CSS technique, bork the display editor's ajax drag-and-drop, it's important
 *       that the $output be printed, not returned. Use this syntax in the caller function: \n
 *          print theme('page', panels_edit($display, $destination, $content_types), FALSE); \n
 *    -# If $_POST['op'] == t('Cancel'): form submission has been cancelled. If empty($destination) == FALSE,
 *       then there is no return value and the panels API takes care of redirecting to $destination.
 *       If empty($destination) == TRUE, then there's still no return value, but the caller function
 *       has to take care of form redirection.
 *    -# If $_POST['op'] == ('Save'): the form has been submitted successfully and has run through
 *        panels_edit_display_submit(). $output depends on the value of $destination:
 *      - If empty($destination) == TRUE: $output contains the modified $display
 *        object, and no redirection will occur. This option is useful if the caller
 *        needs to perform additional operations on or with the modified $display before
 *        the page request is complete. Using hook_form_alter() to add an additional submit
 *        handler is typically the preferred method for something like this, but there
 *        are certain use cases where that is infeasible and $destination = NULL should
 *        be used instead. If this method is employed, the caller will need to handle form
 *        redirection. Note that having $_REQUEST['destination'] set, whether via
 *        drupal_get_destination() or some other method, will NOT interfere with this
 *        functionality; consequently, you can use drupal_get_destination() to safely store
 *        your desired redirect in the caller function, then simply use drupal_goto() once
 *        panels_edit() has done its business.
 *      - If empty($destination) == FALSE: the form will redirect to the URL string
 *        given in $destination and NO value will be returned.
 */
function panels_edit($display, $destination = NULL, $content_types = NULL) {
  panels_load_include('display_edit');
  panels_load_include('plugins');
  return _panels_edit($display, $destination, $content_types);
}

/**
 * API entry point for selecting a layout for a given display.
 *
 * @ingroup MainAPI
 *
 * Layout selection is nothing more than a list of radio items encompassing the available
 * layouts for this display, as defined by .inc files in the panels/layouts subdirectory.
 * The only real complexity occurs when a user attempts to change the layout of a display
 * that has some content in it.
 *
 * @param object $display instanceof panels_display \n
 *  A fully loaded panels $display object, as returned from panels_load_display().
 *  Merely passing a did is NOT sufficient.
 * @param string $finish
 *  A string that will be used for the text of the form submission button. If no value is provided,
 *  then the form submission button will default to t('Save').
 * @param mixed $destination
 *  Basic usage is a string containing the URL that the form should redirect to upon submission.
 *  For a discussion of advanced usages, see panels_edit().
 * @param mixed $allowed_layouts
 *  Allowed layouts has three different behaviors that depend on which of three value types
 *  are passed in by the caller:
 *    #- if $allowed_layouts instanceof panels_allowed_layouts (includes subclasses): the most
 *       complex use of the API. The caller is passing in a loaded panels_allowed_layouts object
 *       that the client module previously created and stored somewhere using a custom storage
 *       mechanism.
 *    #- if is_string($allowed_layouts): the string will be used in a call to variable_get() which
 *       will call the $allowed_layouts . '_allowed_layouts' var. If the data was stored properly
 *       in the system var, the $allowed_layouts object will be unserialized and recreated.
 *       @see panels_common_set_allowed_layouts()
 *    #- if is_null($allowed_layouts): the default behavior, which also provides backwards
 *       compatibility for implementations of the Panels2 API written before beta4. In this case,
 *       a dummy panels_allowed_layouts object is created which does not restrict any layouts.
 *       Subsequent behavior is indistinguishable from pre-beta4 behavior.
 *
 * @return
 *  Can return nothing, or a modified $display object, or a redirection string; return values for the
 *  panels_edit* family of functions are quite complex. See panels_edit() for detailed discussion.
 * @see panels_edit()
 */
function panels_edit_layout($display, $finish, $destination = NULL, $allowed_layouts = NULL) {
  panels_load_include('display_edit');
  panels_load_include('plugins');
  return _panels_edit_layout($display, $finish, $destination, $allowed_layouts);
}

/**
 * API entry point for configuring the layout settings for a given display.
 *
 * @ingroup MainAPI
 *
 * For all layouts except Flexible, the layout settings form allows the user to select styles,
 * as defined by .inc files in the panels/styles subdirectory, for the panels in their display.
 * For the Flexible layout, the layout settings form allows the user to provide dimensions
 * for their flexible layout in addition to applying styles to panels.
 *
 * TODO and at some point, individual panes should be stylable as well as whole panels.
 *
 * @param object $display instanceof panels_display \n
 *  A fully loaded panels $display object, as returned from panels_load_display().
 *  Merely passing a did is NOT sufficient.
 * @param string $finish
 *  A string that will be used for the text of (one of) the form submission button(s). Note that
 *  panels will NOT wrap $finish in t() for you, so your caller should make sure to do so. \n
 *  The submit behavior of the form is primarily governed by the value of $destination (see
 *  below), but is secondarily governed by $finish as follows:
 *    -# If $finish != t('Save'), then two #submit buttons will be present: one with the button
 *       text t('Save'), and the other with the button text $finish. .
 *      - Clicking the 'Save' button will save any changes on the form to the $display object and
 *        keep the user on the same editing page.
 *      - Clicking the $finish button will also save the $display object, but the user will be
 *        redirected to the URL specified in $destination.
 *    -# If $finish == t('Save'), then there is only one button, still called t('Save'), but it
 *       mimics the behavior of the $finish button above by redirecting the user away from the form.
 * @param mixed $destination
 *  Basic usage is a string containing the URL that the form should redirect to upon submission.
 *  For a discussion of advanced usages that rely on NULL values for $destination, see the
 *  panels_edit() documentation.
 * @param mixed $title
 *  The $title variable has three modes of operation:
 *    -# If $title == FALSE (the default), then no widget will appear on the panels_edit_layout_settings form
 *       allowing the user to select a title, and other means for setting page titles will take precedent. If
 *       no other means are used to provide a title, then the title will be hidden when rendering the $display.
 *    -# If $title == TRUE, then two widgets will appear on the panels_edit_layout_settings form allowing the
 *       user to input a title specific to this $display, as well as a checkbox enabling the user to disable
 *       page titles entirely for this $display object.
 *    -# If $title == (string), then the behavior is very similar to mode 2, but the widget description
 *       on the title textfield will indicate that the $title string will be used as the default page title
 *       if none is provided on this form. When utilizing this option, note that the panels API can only
 *       provide the data for these values; you must implement the appropriate conditionals to make it true.
 *
 * @return
 *  Can return nothing, or a modified $display object, or a redirection string; return values for the
 *  panels_edit* family of functions are quite complex. See panels_edit() for detailed discussion.
 * @see panels_edit()
 */
function panels_edit_layout_settings($display, $finish, $destination = NULL, $title = FALSE) {
  panels_load_include('display_edit');
  panels_load_include('plugins');
  return _panels_edit_layout_settings($display, $finish, $destination, $title);
}


// ---------------------------------------------------------------------------
// panels database functions

/**
 * Forms the basis of a panel display
 *
 * @ingroup MainAPI
 *
 */
class panels_display {
  var $args = array();
  var $content = array();
  var $panels = array();
  var $incoming_content = NULL;
  var $css_id = NULL;
  var $context = array();
  var $title = '';
  var $hide_title = 0;

  function add_pane($pane, $location = FALSE) {
    $pane->pid = $this->next_new_pid();
    if (!$location || !isset($this->panels[$location])) {
      foreach ($this->panels as $panel_name => $panel) {
        if (array_key_exists($pane->pid, $panel)) {
          $this->panels[$panel_name][] = $pane->pid;
        }
      }
    }
    else {
      $this->panels[$location][] = $pane->pid;
    }
  }

  function duplicate_pane($pid, $location = FALSE) {
    $pane = $this->clone_pane($pid);
    $this->add_pane($pane, $location);
  }

  function clone_pane($pid) {
    $pane = drupal_clone($this->content[$pid]);
    foreach (array_keys($this->content) as $pidcheck) {
      // necessary?
      unset($pane->position);
    }
    return $pane;
  }

  function next_new_pid() {
    // necessary if/until we use this method and ONLY this method for adding
    // temporary pids. then we can do it with a nice static var.
    $id = array(0);
    foreach (array_keys($this->content) as $pid) {
      if (!is_numeric($pid)) {
        $id[] = substr($pid, 4);
      }
    }
    $next_id = end($id);
    return ++$next_id;
  }
}

/**
 * Clean up a display and make sure it has some required information if
 * it doesn't already exist. Currently we require a context, an incoming
 * content and a css_id.
 */
function panels_sanitize_display(&$display) {
  if (!isset($display->args)) {
    $display->args = array();
  }

  if (!isset($display->incoming_content)) {
    $display->incoming_content = NULL;
  }

  if (!isset($display->context)) {
    $display->context = array();
  }

  if (!isset($display->css_id)) {
    $display->css_id = NULL;
  }
}

/**
 * Creates a new display, setting the ID to our magic new id.
 *
 * @ingroup MainAPI
 */
function panels_new_display() {
  $display = new panels_display();
  $display->did = 'new';
  return $display;
}

/**
 * Load and fill the requested $display object(s).
 *
 * @ingroup HookInvokers
 *
 * Helper function primarily for for panels_load_display().
 *
 * @param array $dids
 *  An indexed array of dids to be loaded from the database.
 *
 * @return $displays
 *  An array of displays, keyed by their display dids.
 */
function panels_load_displays($dids) {
  $displays = array();
  if (empty($dids) || !is_array($dids)) {
    return $displays;
  }

  $subs = implode(', ', array_fill(0, count($dids), '%d'));

  $result = db_query("SELECT * FROM {panels_display} WHERE did IN ($subs)", $dids);

  while ($obj = db_fetch_array($result)) {
    $display = new panels_display();

    foreach ($obj as $key => $value) {
      $display->$key = $value;
      // unserialize important bits
      if (in_array($key, array('layout_settings', 'panel_settings', 'cache'))) {
        $display->$key = empty($display->$key) ? array() : unserialize($display->$key);
      }
    }

    $display->panels = $display->content = array();

    $displays[$display->did] = $display;
  }

  foreach (module_implements('panels_layout_content_alter') as $module) {
    $function = $module . '_panels_layout_content_alter';
    $function($content, $layout, $settings);
  }

  $result = db_query("SELECT * FROM {panels_pane} WHERE did IN ($subs) ORDER BY did, panel, position", $dids);

  while ($pane = db_fetch_object($result)) {
    $pane->configuration = unserialize($pane->configuration);
    $pane->cache = empty($pane->cache) ? array() : unserialize($pane->cache);
    $pane->access = ($pane->access ? explode(', ', $pane->access) : array());
    // Old panels may not have shown property, so enable by default when loading.
    $pane->shown = isset($pane->shown) ? $pane->shown : TRUE;

    $displays[$pane->did]->panels[$pane->panel][] = $pane->pid;
    $displays[$pane->did]->content[$pane->pid] = $pane;
  }
  return $displays;
}

/**
 * Load a single display.
 *
 * @ingroup MainAPI
 *
 * @param int $did
 *  The display id (did) of the display to be loaded.
 *
 * @return object $display instanceof panels_display \n
 *  Returns a partially-loaded panels_display object. $display objects returned from
 *  from this function have only the following data:
 *    - $display->did (the display id)
 *    - $display->name (the 'name' of the display, where applicable - it often isn't)
 *    - $display->layout (a string with the system name of the display's layout)
 *    - $display->panel_settings (custom layout style settings contained in an associative array; NULL if none)
 *    - $display->layout_settings (panel size and configuration settings for Flexible layouts; NULL if none)
 *    - $display->css_id (the special css_id that has been assigned to this display, if any; NULL if none)
 *    - $display->content (an array of pane objects, keyed by pane id (pid))
 *    - $display->panels (an associative array of panel regions, each an indexed array of pids in the order they appear in that region)
 *    - $display->cache (any relevant data from panels_simple_cache)
 *    - $display->args
 *    - $display->incoming_content
 *
 * While all of these members are defined, $display->context is NEVER defined in the returned $display;
 * it must be set using one of the panels_context_create() functions.
 */
function panels_load_display($did) {
  $displays = panels_load_displays(array($did));
  if (!empty($displays)) {
    return array_shift($displays);
  }
}

/**
 * Save a display object.
 *
 * @ingroup MainAPI
 *
 * Note a new $display only receives a real did once it is run through this function.
 * Until then, it uses a string placeholder, 'new', in place of a real did. The same
 * applies to all new panes (whether on a new $display or not); in addition,
 * panes have sequential numbers appended, of the form 'new-1', 'new-2', etc.
 *
 * @param object $display instanceof panels_display \n
 *  The display object to be saved. Passed by reference so the caller need not use
 *  the return value for any reason except convenience.
 *
 * @return object $display instanceof panels_display \n
 */
function panels_save_display(&$display) {
  if ($display->did && $display->did != 'new') {
    if (empty($display->cache)) {
      $display->cache = array();
    }
    db_query("UPDATE {panels_display} SET layout = '%s', layout_settings = '%s', panel_settings = '%s', cache = '%s', title = '%s', hide_title = %d WHERE did = %d", $display->layout, serialize($display->layout_settings), serialize($display->panel_settings), serialize($display->cache), $display->title, $display->hide_title, $display->did);
    db_query("DELETE FROM {panels_pane} WHERE did = %d", $display->did);
  }
  else {
    $display->did = db_next_id("{panels_display}_did");
    db_query("INSERT INTO {panels_display} (did, layout, layout_settings, panel_settings, cache, title, hide_title) VALUES (%d, '%s', '%s', '%s', '%s', '%s', %d)", $display->did, $display->layout, serialize($display->layout_settings), serialize($display->panel_settings), serialize($display->cache), $display->title, $display->hide_title);
  }

  // update all the panes
  panels_load_include('plugins');
  foreach ((array) $display->panels as $id => $panes) {
    $position = 0;
    $new_panes = array();
    foreach ((array) $panes as $pid) {
      $pane = $display->content[$pid];
      $pane->position = $position++;
      if (!is_numeric($pid)) {
        unset($display->content[$pid]);
        $pane->pid = db_next_id("{panels_pane}_pid");
      }
      if (empty($pane->cache)) {
        $pane->cache = array();
      }

      $type = panels_get_content_type($pane->type);
      $access = isset($pane->access) ? implode(', ', $pane->access) : '';
      $visibility = $type['visibility serialize'] ? serialize($pane->visibility) : $pane->visibility;
      // doin it this way for readability
      $f = 'pid, did, panel, type, subtype, configuration, cache, shown, access, visibility, position';
      $q = "%d, %d, '%s', '%s', '%s', '%s', '%s', '%s', '%s', '%s', %d";
      $pane->shown = isset($pane->shown) ? $pane->shown : TRUE;
      $v = array($pane->pid, $display->did, $pane->panel, $pane->type, $pane->subtype, serialize($pane->configuration), serialize($pane->cache), $pane->shown, $access, $visibility, $pane->position);
      db_query("INSERT INTO {panels_pane} ($f) VALUES ($q)", $v);
      // and put it back so our pids and positions can be used
      $display->content[$pane->pid] = $pane;
      $new_panes[] = $pane->pid;
    }
    $display->panels[$id] = $new_panes;
  }

  // Clear any cached content for this display.
  panels_clear_cached_content($display);

  // to be nice, even tho we have a reference.
  return $display;
}

/**
 * Delete a display.
 * @ingroup MainAPI
 */
function panels_delete_display($display) {
  if (is_object($display)) {
    $did = $display->did;
  }
  else {
    $did = $display;
  }
  db_query("DELETE FROM {panels_display} WHERE did = %d", $did);
  db_query("DELETE FROM {panels_pane} WHERE did = %d", $did);
}

/**
 * Exports the provided display into portable code.
 *
 * @ingroup MainAPI
 *
 * This function is primarily intended as a mechanism for cloning displays.
 * It generates an exact replica (in code) of the provided $display, with
 * the exception that it replaces all ids (dids and pids) with 'new-*' values.
 * Only once panels_save_display() is called on the code version of $display will
 * the exported display written to the database and permanently saved.
 *
 * @see panels_page_export() or _panels_page_fetch_display() for sample implementations.
 *
 * @param object $display instanceof panels_display \n
 *  This export function does no loading of additional data about the provided
 *  display. Consequently, the caller should make sure that all the desired data
 *  has been loaded into the $display before calling this function.
 * @param string $prefix
 *  A string prefix that is prepended to each line of exported code. This is primarily
 *  used for prepending a double space when exporting so that the code indents and lines up nicely.
 *
 * @return string $output
 *  The passed-in $display expressed as code, ready to be imported. Import by running
 *  eval($output) in the caller function; doing so will create a new $display variable
 *  with all the exported values. Note that if you have already defined a $display variable in
 *  the same scope as where you eval(), your existing $display variable WILL be overwritten.
 */
function panels_export_display($display, $prefix = '') {
  $output = '';
  $output .= $prefix . '$display = new panels_display()' . ";\n";
  $output .= $prefix . '$display->did = \'new\'' . ";\n";
  $fields = array('name', 'layout', 'layout_settings', 'panel_settings');
  foreach ($fields as $field) {
    if (!empty($display->$field)) {
      $output .= $prefix . '$display->' . $field . ' = ' . panels_var_export($display->$field, $prefix) . ";\n";
    }
  }

  $output .= $prefix . '$display->content = array()' . ";\n";
  $output .= $prefix . '$display->panels = array()' . ";\n";
  $panels = array();

  if (!empty($display->content)) {
    $pid_counter = 0;
    $region_counters = array();
    foreach ($display->content as $pane) {
      $pane->pid = 'new-' . ++$pid_counter;
      $output .= panels_export_pane($pane, $prefix . '  ');
      $output .= "$prefix  " . '$display->content[\'' . $pane->pid . '\'] = $pane' . ";\n";
      if (!isset($region_counters[$pane->panel])) {
        $region_counters[$pane->panel] = 0;
      }
      $output .= "$prefix  " . '$display->panels[\'' . $pane->panel . '\'][' . $region_counters[$pane->panel]++ .'] = \'' . $pane->pid . "';\n";
    }
  }
  return $output;
}

function panels_export_pane($pane, $prefix = '') {
  $output = '';
  $output = $prefix . '$pane = new stdClass()'  . ";\n";
  $fields = array('pid', 'panel', 'type', 'subtype', 'access', 'configuration', 'shown');
  foreach ($fields as $field) {
    $output .= "$prefix  " . '$pane->' . $field . ' = ' . panels_var_export($pane->$field, "$prefix  ") . ";\n";
  }
  return $output;
}

function panels_var_export($object, $prefix = '') {
  if (is_array($object) && empty($object)) {
    $output = 'array()';
  }
  else {
    $output = var_export($object, TRUE);
  }

  if ($prefix) {
    $output = str_replace("\n", "\n$prefix", $output);
  }
  return $output;
}

/**
 * Render a display by loading the content into an appropriate
 * array and then passing through to panels_render_layout.
 *
 * @ingroup MainAPI
 * @ingroup HookInvokers
 * @ingroup render
 *
 * if $incoming_content is NULL, default content will be applied. Use
 * an empty string to indicate no content.
 */
function panels_render_display(&$display) {
  panels_load_include('plugins');
  $layout = panels_get_layout($display->layout);
  if (!$layout) {
    return NULL;
  }

  // TODO: This may not be necessary now. Check this.
  panels_sanitize_display($display);

  $output = '';

  // Let modules act just prior to render.
  foreach (module_implements('panels_pre_render') as $module) {
    $function = $module . '_panels_pre_render';
    $output .= $function($display);
  }

  $output .= panels_render_layout($layout, $display, $display->css_id, $display->layout_settings);

  // Let modules act just after render.
  foreach (module_implements('panels_post_render') as $module) {
    $function = $module . '_panels_post_render';
    $output .= $function($display);
  }
  return $output;
}

/**
 * For external use: Given a layout ID and a $content array, return the
 * panel display. The content array is filled in based upon the content
 * available in the layout. If it's a two column with a content
 * array defined like array('left' => t('Left side'), 'right' =>
 * t('Right side')), then the $content array should be array('left' =>
 * $output_left, 'right' => $output_right)
 * @ingroup render
 */
function panels_print_layout($id, $content) {
  panels_load_include('plugins');
  $layout = panels_get_layout($id);
  if (!$layout) {
    return;
  }

  return panels_render_layout($layout, $content);
}

/**
 * Given a full layout structure and a content array, render a panel display.
 * @ingroup render
 */
function panels_render_layout($layout, $content, $css_id = NULL, $settings = array()) {
  if (!empty($layout['css'])) {
    if (file_exists(path_to_theme() . '/' . $layout['css'])) {
      drupal_add_css(path_to_theme() . '/' . $layout['css']);
    }
    else {
      drupal_add_css(panels_get_path($layout['css'], false, $layout['module']));
    }
  }
  $display = NULL;

  // This now comes after the CSS is added, because panels-within-panels must
  // have their CSS added in the right order; inner content before outer content.

  // If $content is an object, it's a $display and we have to render its panes.
  if (is_object($content)) {
    $display = $content;
    if (empty($display->cache['method'])) {
      $content = panels_render_panes($display);
    }
    else {
      $cache = panels_get_cached_content($display, $display->args, $display->context);
      if ($cache === FALSE) {
        $cache = new panels_cache_object();
        $cache->set_content(panels_render_panes($display));
        panels_set_cached_content($cache, $display, $display->args, $display->context);
      }
      $content = $cache->content;
    }
  }

  $output = theme($layout['theme'], check_plain($css_id), $content, $settings, $display);

  return $output;
}

/**
 * Render all the panes in a display into a $content array to be used by
 * the display theme function.
 */
function panels_render_panes($display) {
  // Safety check.
  if (empty($display->content)) {
    return array();
  }

  // First, render all the panes into little boxes. We do this here because
  // some panes request to be rendered after other panes (primarily so they
  // can do the leftovers of forms).
  $panes = array();
  $later = array();

  foreach ($display->content as $pid => $pane) {
    $pane->shown = isset($pane->shown) ? $pane->shown : TRUE;
    // TODO Really ought to design a method for creating a quick-access set of content_type (and other plugin) data to help optimize render performance
    // If the user can't see this pane, do not render it.
    if (!$pane->shown || !panels_pane_access($pane, $display)) {
      continue;
    }

    // If this pane wants to render last, add it to the $later array.
    $content_type = panels_get_content_type($pane->type);

    if (!empty($content_type['render last'])) {
      $later[$pid] = $pane;
      continue;
    }

    $panes[$pid] = panels_render_pane_content($display, $pane);
  }

  foreach ($later as $pid => $pane) {
    $panes[$pid] = panels_render_pane_content($display, $pane);
  }

  // Loop through all panels, put all panes that belong to the current panel
  // in an array, then render the panel. Primarily this ensures that the
  // panes are in the proper order.
  $content = array();
  foreach ($display->panels as $panel_name => $pids) {
    $panel = array();
    foreach ($pids as $pid) {
      if (!empty($panes[$pid])) {
        $panel[$pid] = $panes[$pid];
      }
    }
    $content[$panel_name] = panels_render_panel($display, $panel_name, $panel);
  }

  return $content;
}

/**
 * Render a single pane, identifying its context, and put it into
 * the $panes array.
 */
function panels_render_pane_content(&$display, &$pane) {
  if (empty($pane->context)) {
    $pane->context = panels_pane_select_context($pane, $display->context);
    if ($pane->context === FALSE) {
      return FALSE;
    }
  }

  $content = panels_get_pane_content($display, $pane, $display->args, $pane->context, $display->incoming_content);

  $keywords = !empty($display->keywords) ? $display->keywords : array();
  // Override the title if configured to
  if (!empty($pane->configuration['override_title'])) {
    // Give previous title as an available substitution here.
    $keywords['%title'] = $content->title;
    $content->title = $pane->configuration['override_title_text'];
  }

  // Pass long the css_id that is usually available.
  if (!empty($pane->configuration['css_id'])) {
    $content->css_id = $pane->configuration['css_id'];
  }

  // Pass long the css_class that is usually available.
  if (!empty($pane->configuration['css_class'])) {
    $content->css_class = $pane->configuration['css_class'];
  }

  // Perform substitutions
  if (!empty($keywords)) {
    $content->title = strtr($content->title, $keywords);
  }

  // Sterilize the title
  $content->title = filter_xss_admin($content->title);

  // If a link is specified, populate.
  if (!empty($content->title_link)) {
    if (!is_array($content->title_link)) {
      $url = array('href' => $content->title_link);
    }
    else {
      $url = $content->title_link;
    }
    // set defaults so we don't bring up notices
    $url += array('href' => '', 'attributes' => NULL, 'query' => NULL, 'fragment' => NULL, 'absolute' => NULL);
    $content->title = l($content->title,
      $url['href'],
      $url['attributes'],
      $url['query'],
      $url['fragment'],
      $url['absolute'], TRUE);
  }
  return $content;
}

/**
 * Render a pane using the appropriate style.
 *
 * $content
 *   The already rendered content via panels_render_pane_content()
 * $pane
 *   The $pane information from the display
 * $display
 *   The display.
 */
function panels_render_pane($content, $pane, $display) {
  if (!empty($pane->configuration['style'])) {
    $style = panels_get_style($pane->configuration['style']);

    if (isset($style)) {
      $output = theme($style['render pane'], $content, $pane, $display);

      // This could be null if no theme function existed.
      if (isset($output)) {
        return $output;
      }
    }
  }

  // fallback
  return theme('panels_pane', $content, $pane, $display);
}

/**
 * Given a display and the id of a panel, get the style in which to render
 * that panel.
 */
function panels_get_panel_style_and_settings($panel_settings, $panel) {
  if (empty($panel_settings)) {
    return array(panels_get_style('default'), array());
  }

  if (empty($panel_settings['individual']) || empty($panel_settings['panel'][$panel]['style'])) {
    $style = panels_get_style($panel_settings['style']);
    $style_settings = $panel_settings['style_settings']['default'];
  }
  else {
    $style = panels_get_style($panel_settings['panel'][$panel]['style']);
    $style_settings = $panel_settings['style_settings'][$panel];
  }

  return array($style, $style_settings);
}

/**
 * Render a panel, by storing the content of each pane in an appropriate array
 * and then passing through to the theme function that will render the panel
 * in the configured panel style.
 *
 * @param $display
 *   A display object.
 * @param $panel
 *   The ID of the panel being rendered
 * @param $panes
 *   An array of panes that are assigned to the panel that's being rendered.
 *
 * @return
 *   The rendered HTML for a panel.
 * @ingroup render
 */
function panels_render_panel($display, $panel, $panes) {
  list($style, $style_settings) = panels_get_panel_style_and_settings($display->panel_settings, $panel);

  // Retrieve the pid (can be a panel page id, a mini panel id, etc.), this
  // might be used (or even necessary) for some panel display styles.
  // TODO: Got to fix this to use panel page name instead of pid, since pid is
  // no longer guaranteed. This needs an API to be able to set the final id.
  $owner_id = 0;
  if (isset($display->owner) && is_object($display->owner) && isset($display->owner->id)) {
    $owner_id = $display->owner->id;
  }

  return theme($style['render panel'], $display, $owner_id, $panes, $style_settings, $panel);
}

/**
 * Print the layout link. Sends out to a theme function.
 * @layout
 */
function panels_print_layout_link($id, $layout, $link) {
  drupal_add_css(panels_get_path('css/panels_admin.css'));
  $file  = panels_get_path($layout['icon'], false, $layout['module']);
  $image = l(theme('image', $file), $link, NULL, NULL, NULL, NULL, TRUE);
  $title = l($layout['title'], $link);
  return theme('panels_layout_link', $title, $id, $image, $link);
}

// @layout
function panels_print_layout_icon($id, $layout, $title = NULL) {
  drupal_add_css(panels_get_path('css/panels_admin.css'));
  $file = panels_get_path($layout['icon'], false, $layout['module']);
  return theme('panels_layout_icon', $id, theme('image', $file), $title);
}

/**
 * Theme the layout link image
 * @layout
 */
function theme_panels_layout_link($title, $id, $image, $link) {
  $output .= '<div class="layout-link">';
  $output .= $image;
  $output .= '<div>' . $title . '</div>';
  $output .= '</div>';
  return $output;
}

/**
 * Theme the layout icon image
 * @layout
 */
function theme_panels_layout_icon($id, $image, $title = NULL) {
  $output .= '<span class="layout-icon">';
  $output .= $image;
  if ($title) {
    $output .= '<span class="caption">' . $title . '</span>';
  }
  $output .= '</span>';
  return $output;
}

/**
 * Render a panel pane like a block.
 *
 * A panel pane can have the following fields:
 *
 *  - $pane->type -- the content type inside this pane
 *  - $pane->subtype -- The subtype, if applicable. If a view it will be the
 *    view name; if a node it will be the nid, etc.
 *  - $content->title -- The title of the content
 *  - $content->content -- The actual content
 *  - $content->links -- Any links associated with the content
 *  - $content->more -- An optional 'more' link (destination only)
 *  - $content->admin_links -- Administrative links associated with the content
 *  - $content->feeds -- Any feed icons or associated with the content
 *  - $content->subject -- A legacy setting for block compatibility
 *  - $content->module -- A legacy setting for block compatibility
 *  - $content->delta -- A legacy setting for block compatibility
 */
function theme_panels_pane($content, $pane, $display) {
  if (!empty($content->content)) {
    $idstr = $classstr = '';
    if (!empty($content->css_id)) {
      $idstr = ' id="' . $content->css_id . '"';
    }
    if (!empty($content->css_class)) {
      $classstr = ' ' . $content->css_class;
    }

    $output = "<div class=\"panel-pane$classstr\"$idstr>\n";
    if (user_access('view pane admin links') && !empty($content->admin_links)) {
      $output .= "<div class=\"admin-links panel-hide\">" . theme('links', $content->admin_links) . "</div>\n";
    }
    if (!empty($content->title)) {
      $output .= "<h2 class=\"title\">$content->title</h2>\n";
    }

    if (!empty($content->feeds)) {
      $output .= "<div class=\"feed\">" . implode(' ', $content->feeds) . "</div>\n";
    }

    $output .= "<div class=\"content\">$content->content</div>\n";

    if (!empty($content->links)) {
      $output .= "<div class=\"links\">" . theme('links', $content->links) . "</div>\n";
    }


    if (!empty($content->more)) {
      if (empty($content->more['title'])) {
        $content->more['title'] = t('more');
      }
      $output .= "<div class=\"more-link\">" . l($content->more['title'], $content->more['href']) . "</div>\n";
    }

    $output .= "</div>\n";
    return $output;
  }
}

/**
 * Helper function for parsing an autocomplete node field.
 *
 * @param $string
 *   A string in autocomplete syntax (e.g. ".... [nid: 123]"), or a
 *   typed-in nid, or a node title.
 *
 * @return
 *   Either a valid nid or NULL.
 */
function panels_nid_autocomplete($int) {
  $nid = NULL;
  if (is_numeric($int)) {
    // The user typed a NID outright.
    $nid = $int;
  }
  else {
    // Else, it might be an autocomplete syntax.
    $preg_matches = array();
    $match = preg_match('/\[nid: (\d+)\]/', $int, $preg_matches)
             || preg_match('/^nid: (\d+)/', $int, $preg_matches);
    if ($match) {
      $nid = $preg_matches[1];
    }
  }
  if (isset($nid)) {
    // Verify that node exists and we have access to it.
    $node = db_fetch_object(db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.nid = %d"), $nid));
  }
  else {
    // Try to find a node having that title.
    $node = db_fetch_object(db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE LOWER(n.title) = LOWER('%s')"), $int));
  }
  if ($node) {
    return $node->nid;
  }
}
/**
 * Helper function for autocompletion of node titles.
 * This is mostly stolen from clipper.
 */
function panels_node_autocomplete($string) {
  // TODO: Compare this to the nodequeue version, see which is better.
  // TODO: The nodequeue version is totally better. Steal it.
  // if there are node_types passed, we'll use those in a MySQL IN query.
  if ($string != '') {
    $preg_matches = array();
    $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
    if (!$match) {
      $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
    }
    if ($match) {
      $arg = $preg_matches[1];
      $where = "n.nid = %d";
    }
    else {
      $arg = $string;
      $where = "LOWER(title) LIKE LOWER('%%%s%%')";
    }
    $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, u.name FROM {node} n INNER JOIN {users} u ON u.uid = n.uid WHERE $where"), $arg, 0, 10);

    $matches = array();
    while ($node = db_fetch_object($result)) {
      $name = empty($node->name) ? variable_get('anonymous', t('Anonymous')) : check_plain($node->name);
      $matches[$node->title . " [nid: $node->nid]"] = '<span class="autocomplete_title">'. check_plain($node->title) .'</span> <span class="autocomplete_user">('. t('by @user', array('@user' => $name)) .')</span>';
    }
    drupal_set_header('Content-Type: text/javascript; charset=utf-8');
    print drupal_to_js($matches);
  }
}

/**
 * Implementation of hook_node_type().
 *
 * We implement this hook to update any pane contexts that are reliant on a
 * specific node type with the new type name.
 */
function panels_node_type($op, $info) {
  if ($op == 'update') {
    if (!empty($info->old_type) && $info->old_type != $info->type) {
      // Exclude a few common pane types that we know don't use context.
      $result = db_query("SELECT * FROM {panels_pane} WHERE type NOT IN ('block', 'custom')");
      while ($pane = db_fetch_object($result)) {
        // Check the serialized data for the presence of context data.
        if (!preg_match('/s:7:\"context/', $pane->configuration) || stripos($pane->configuration, 'node-' . $info->old_type) === FALSE) {
          // There's no context/no mention of our node type - next!
          continue;
        }
        $conf = unserialize($pane->configuration);
        // Manage panes with multiple contexts stored in an array.
        if (is_array($conf['context'] && ($keys = array_keys($conf['context'], 'node-' . $info->old_type)))) {
          foreach ($keys as $key) {
            $conf['context'][$key] = 'node-' . $info->type;
          }
          db_query("UPDATE {panels_pane} SET configuration = '%s' WHERE pid = %d", serialize($conf), $pane->pid);
        }
        // Manage single-context panes.
        else if ($conf['context'] == 'node-' . $info->old_type) {
          $conf['context'] = 'node-' . $info->type;
          db_query("UPDATE {panels_pane} SET configuration = '%s' WHERE pid = %d", serialize($conf), $pane->pid);
        }
      }
    }
  }
}
